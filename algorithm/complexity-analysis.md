# 复杂度

## 时间复杂度

假设有一个整数数组，数组内有`N`个整数，现在有三个方法用来处理这个数组，这三个方法的分别是

1. 简单返回数组第一个元素加上 1

```
F(1) = 1 + a[0]
```

2. 求所有元素相加的和并返回

```
F(2) = sum(a)
```

3. 将数组排成逐个元素相关联的阵列并返回，如传入`[1, 2, 3]`则返回`[1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 3, 3, 1, 3, 2, 3, 3]`

```
F(3) = peri(a)
```

首先看变化的是数组的元素个数`N`，随着`N`不断趋于无穷大，三个方法处理的时间也慢慢增加，三个方法的时间复杂度可以分别表示为

1. F(1) = O(1)
2. F(2) = O(N)
3. F(3) = O(N<sup>2</sup>)

第三个方法因为需要对每个元素按`N`的数量排列`N`次，故为`N * N`次，也就是`N`的平方

复杂度可能有非常多的表示方法，按如

- O(1)
- O(N)
- O(log(N))
- O(N<sup>2</sup>)
- O(log(N<sup>2</sup>))
- O(2<sup>N</sup>)
- O(M<sup>N</sup>)

当分析一个复杂度时，如果复杂度表达式里面的存在常量，或变化较小的量时，是可以忽略掉的，如 O(N<sup>2</sup> + N + 1) 中的
N + 1 是可以忽略的，因为相对于 N<sup>2</sup> 来说，N + 1 的变化太小了。再比如 O(N<sup>2</sup> + log(N) + 2N + 3) 中
，2N + 3 是可以忽略的。这其实是算是数学中的公式简化，但又不是特别的严谨

在算法复杂度分析中 log(N)表示以 2 为底 N 的对数，如 N=32，则 log(32)=5，即 2<sup>5</sup>=32，与数学中不写底数则以 10 为
底的默认表示有区别。随着 N 不断翻倍增长，log(N)的值变化也是相对较小的

比如有一个算法，接收一个数组作为参数，每次循环执行时都将数组一分为二，直到只剩下一个元素，那么这个算法的复杂度就是
O(log(N))，N 表示输入数组的元素个数，当数组为 8 个元素时，算法循环 3 次，当数组元素为 16 个时，算法循环 4 次，以此类推

还有另一种 log(N)的表示方式，平衡二叉树寻找，每次只能选择一个子节点，左边或右边，如果选择了左边，则右边的节点就不会再被
访问到了，如此选择直到树的末尾，随着树的层级越来越深，子节点越来越多，以 N 表示树中的节点数量，则每次做出选择的次数就可
以近似的表示为 log(N)

Last Modified 2021-06-12
