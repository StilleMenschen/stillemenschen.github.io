# 数据结构

## 比特

即`bit`，二进制数的缩写，比特是计算机科学中的基本信息单位，表示具有两个值之一的状态，通常为`0`和`1`。
从最基础的层面来看，存储在计算机中的任何数据都以`bit`表示

## 字节

即`byte`，一组八位，例如`01101001`是一个字节。一个字节最多可以表示`256`个数据值（2<sup>8</sup>）

由于二进制数是仅用两个符合表示的数字，因此一个字节可以有效地以二进制格式表示`0`到`255`之间的所有数字

```
1：00000001
2：00000010
3：00000011
4：00000100
```

## 固定位宽整数

由固定位数表示的整数，如 32 位整数是 32 位（4 字节）表示的整数，64 位整数是 64 位（8 字节）表示的整数

以下是数字 1 的 32 位表示形式，具有明显分隔的字节

```
00000000 00000000 00000000 00000001
```

以下是数字 10 的 64 位表示形式，具有明显分隔的字节

```
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010
```

## 内存

从广义上来看，内存是计算机的基础，所有的数据都存储在其中。在算法面试中，重要的是要注意以下几点：

- 存储在内存中的数据以字节存储，进而以位存储
- 内存中的字节可以“指向”内存中的其它字节，从而存储对其它数据的引用
- 机器的内存量是有限的，因此限制算法占用的内存量非常有价值
- 访问一个字节或固定数量的字节（如 32 位和 64 位整数的 4 个字节或 8 个字节）是一种基本操作，可以简单地视为单个操作单元

## 复杂度

假设有一个整数数组，数组内有`N`个整数，现在有三个方法用来处理这个数组，这三个方法的分别是

1. 简单返回数组第一个元素加上 1

```
F(1) = 1 + a[0]
```

2. 求所有元素相加的和并返回

```
F(2) = sum(a)
```

3. 将数组排成逐个元素相关联的阵列并返回（排列组合），如传入`[1, 2, 3]`则返回`[1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 3, 3, 1, 3, 2, 3, 3]`

```
F(3) = peri(a)
```

首先看变化的是数组的元素个数`N`，随着`N`不断趋于无穷大，三个方法处理的时间也慢慢增加，三个方法的时间复杂度可以分别表示为

1. F(1) = O(1)
2. F(2) = O(N)
3. F(3) = O(N<sup>2</sup>)

第三个方法因为需要对每个元素按`N`的数量排列`N`次，故为`N * N`次，也就是`N`的平方

复杂度可能有非常多的表示方法，按如

- 常数：O(1)
- 线性：O(N)
- 对数：O(log(N))
- 对数线性：O(N \* log(N))
- 二次方：O(N<sup>2</sup>)
- 立方：O(N<sup>3</sup>)
- 指数：O(2<sup>N</sup>)
- 阶乘：O(N!)

当分析一个复杂度时，如果复杂度表达式里面的存在常量，或变化较小的量时，是可以忽略掉的，如 O(N<sup>2</sup> + N + 1) 中的 N + 1 是可以忽略的，
因为相对于 N<sup>2</sup> 来说，N + 1 的变化太小了。再比如 O(N<sup>2</sup> + log(N) + 2N + 3) 中，
2N + 3 是可以忽略的。这其实是算是数学中的公式简化，但又不是特别的严谨

在算法复杂度分析中 log(N) 表示以 2 为底 N 的对数，如 N=32，则 log(32)=5，即 2<sup>5</sup>=32，与数学中不写底数则以 10 为底的默认表示有区别。
随着 N 不断翻倍增长，log(N)的值变化也是相对较小的

比如有一个算法，接收一个数组作为参数，每次循环执行时都将数组一分为二，直到只剩下一个元素，那么这个算法的复杂度就是 O(log(N))，
N 表示输入数组的元素个数，当数组为 8 个元素时，算法循环 3 次，当数组元素为 16 个时，算法循环 4 次，以此类推

还有另一种 log(N)的表示方式，平衡二叉树寻找，每次只能选择一个子节点，左边或右边，如果选择了左边，则右边的节点就不会再被访问到，
如此选择一直到树的末尾，随着树的层级越来越深，子节点越来越多，以 N 表示树中的节点数量，则每次做出选择的次数就可以近似的表示为 log(N)

## 数组（Arrays）

必须占用连续的内存空间，随机访问较快，索引从 0 开始，N 表示元素数量

以下是数组的标准操作及其对应的时间复杂度:

- 访问给定索引处的值：O(1)
- 更新给定索引处的值：O(1)
- 在开头插入-一个值：O(n)
- 在中间插入一个值：O(n)
- 在末尾插入一个值:
  - 处理动态数组时的摊销 O(1)
  - 处理静态数组时的 O(n)
- 在开头删除一 个值：O(n)
- 删除中间的值：O(n)
- 最后删除一个值：O(1)
- 复制数组：O(n)

静态数组是数组的一种实现，它分配固定数量的内存用于存储数组的值。因此，将值附加到数组涉及复制整个数组并为其分配新内存，从而考虑新附加值所需的额外空间。这是一个线性时间操作。

动态数组是数组的一种实现，它预先分配存储数组值所需的内存量的两倍。将值附加到数组是一个恒定时间操作， 直到分配的内存被填满，此时数组被复制并再次为其分配双倍内存。这种实现导致了一个摊销的固定时间插入操作。

许多流行的编程语言（如 JavaScript 和 Python）将数组实现为动态数组。

## 链表（Linked Lists）

不要求连续的内存空间，随机访问较慢，i 表示索引（从 0 开始），N 表示元素数量

### 单链表（Singly Linked List）

一种由节点组成的数据结构，每个节点都有一些值和指向链表中下一个节点的指针。链表节点的值和下一个节点通常分布存储在`value`和`next`属性中。

链表中的第一个节点称为链表的头，而链表中的最后一个节点，其`next`属性指向空值，被称为链表的尾部。

下面是一个单链表的可视化表示， 其节点包含整数值：

```
0 -> 1 -> 2 -> 3 -> 4 -> 5 -> null
```

单链表通常将其头部暴露给用户以便于访问。虽然在单链表中查找节点涉及遍历通向相关节点的所有节点（与使用数组的即时访问相反），但添加或删除节点仅涉及覆盖下一个指针（假设您可以访问要添加或删除的节点之前的节点）。

以下是单链表的标准操作及其对应的时间复杂度:

- 访问头部：O(1)
- 访问尾部：O(n)
- 访问中间节点：O(n)
- 插入/移除头部：O(1)
- 插入/移除尾部：O(m) 访问 + O(1) 操作
- 插入/移除中间节点：O(n) 访问 + O(1) 操作
- 搜索值：O(n)

### 双向链表（Doubly Linked List）

与单链表类似，只是双向链表中的每个节点也有一个指向链表中前一个节点的指针。前一个节点通常存储在一个`prev`属性中。

与单链表类似，双向链表中最后一个节点的`next`指向一个空值，而双向链表的表头`prev`也是指向一个空值的，用以表示开头。

下面是一个双向链表的可视化表示，其节点保存整数值：

```
null <- 0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 -> null
```

虽然双向链表通常向其用户公开它的头和尾，而不是在单链表的情况下只向用户公开它的头，但它在其他方面的行为与单链表非常相似。

以下是双向链表的标准操作及其对应的时间复杂度：

- 访问头部：O(1)
- 访问尾部：O(1)
- 访问中间节点：O(n)
- 插入/移除头部：O(1)
- 插入/移除尾部：O(1)
- 插入/移除中间节点：O(n) 访问 + O(1) 操作
- 搜索值：O(n)

### 循环链表（Circular Linked List）

一个没有明确头尾的链表，因为它的"尾"指向它的"头"，有效地形成了一个封闭的圆圈。循环链表可以是单循环链表，也可以是双循环链表。

## 哈希表（Hash Tables）

一种提供快速插入、删除和查找键/值对的数据结构。

在底层，哈希表使用基于链表的动态数组来有效地存储键/值对。插入键/值对时，哈希函数首先将键（通常是字符串（或任何可以哈希的数据，取决于哈希表的实现））映射到整数值，并扩展为底层动态数组中的索引。然后，与键关联的值被添加到存储在动态数组中该索引处的链表中，并且对键的引用也与该值一起存储。

哈希表依靠高度优化的哈希函数来最小化存储值时发生的冲突数量：两个键映射到同一个索引的情况。

下面是一个哈希表的例子：

```
[
  0: (value1, key1) -> null
  1: (value2, key2) -> (value3, key3) -> (value4, key4)
  2: (value5, key5) -> null
  3: (value6, key6) -> null
  4: null
  5: (value7, key7) -> (value8, key8)
  6: (value9, key9) -> null
]
```

在上面的哈希表中，键 key2、key3 和 key4 发生冲突，都被哈希为 1，键 key 7 和 key8 发生冲突，两者都被哈希为 5。

以下是哈希表的标准操作及其对应的时间复杂度：

- 插入键/值对：平均 O(1)；O(n) 在最坏的情况下
- 删除键/值对：平均 O(1)；O(n) 在最坏的情况下
- 查找键：平均 O(1)；O(n) 在最坏的情况下

最坏情况的线性时间操作发生在哈希表遇到大量冲突时，导致内部链表很长，需要 O(n) 时间来遍历。

然而，在实践中，尤其是在算法面试中，我们通常假设哈希表使用的哈希函数经过优化，以至于冲突极为罕见，并且几乎可以保证恒定时间的操作。

## 栈和队列（Stacks And Queues）

### 栈

一种类似数组的数据结构，其元素遵循 LIFO 原则：Last In, First Out。

通常可以用桌面上的一摞书来比较：最后一本放在这一摞书中的书是第一本优先被拿走的书

以下是栈的标准操作及其对应的时间复杂度

- 将元素压入栈中：O(1)
- 从栈中弹出一个元素：O(1)
- 查看栈顶元素：O(1)
- 在栈中搜索元素：O(n)

栈通常使用动态数组或者单链表来实现

### 队列

一种类似数组的数据结构，其元素遵循 FIFO 原则：First In, First Out。

队列通常可以比作一群人在商店排队购买商品：第一个排队的人是第一个购买完商品并离开的人

以下是栈的标准操作及其对应的时间复杂度

- 将元素加入队列：O(1)
- 从队列中取出一个元素：O(1)
- 查看队列前面的元素：O(1)
- 在队列中搜索元素：O(n)

队列通常使用双向链表实现

## 字符串（Strings）

作为计算机科学中的基本数据类型之一，字符串作为整数数组存储在内存中，其中给定字符串中的每个字符都通过一些字符编码标准 (如 ASCI)映射到整数。

字符串的行为很像普通数组，主要区别在于，在大多数编程语言中(C++ 是一个明显的例外) ，字符串是不可变的，这意味着它们在创建后无法编辑。这也意味着像将字符附加到字符串这样的简单操作比它们看起来更昂贵。

由于字符串不变性而看似昂贵的操作的典型示例如下:

```
string = "this is a string"
newString = ""

for character in string:
    newString += character
```

上述操作的时间复杂度为 O(n<sup>2</sup>)， 其中 n 表示字符数量，因为每增加个字符新字符串创建一个全新的字符串， 它本身就是一个 O(n) 操作。因此，执行了 n 个 O(n) 操作，从而导致总体上 O(n<sup>2</sup>) 的时间复杂度操作。

## 图（Graphs）

一个由节点和边组成的数据结构，一个节点可以有任意的边，每条边可以单向的也可以是双向的，V 表示节点数量，E 表示边的数量，
空间复杂度为 O(V+E)，时间复杂度为 O(V+E)

## 树（Trees）

由一个根节点通过边连接子节点并且子节点也可以拥有子节点，类似一颗倒过来的树一样的数据结构，N 表示节点数量，
一般情况下空间复杂度为 O(N) S，时间复杂度为 O(N) T

- 满二叉树，一个节点要么是叶子节点，要么是包含有左右子树的节点
- 完全二叉树，设二叉树的深度为 k，除第 k 层外，从第 1 层到 k-1 层的结点数都达到最大个数，第 k 层所有的结点都连续集中在最左边
- 平衡二叉树，它或是一颗空树，或它的左子树和右子树的深度之差（平衡因子）的绝对值不超过 1，且它的左子树和右子树都是一颗平衡二叉树
- 霍夫曼树（Huffman Tree），树的带权路径长度达到最小
- 二叉查找树，左子节点总是比父节点小，右子节点总是比父节点大
- 红黑树，可以自平衡的二叉查找树

Last Modified 2022-04-30
