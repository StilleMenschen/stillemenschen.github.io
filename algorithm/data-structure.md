# 数据结构

## 比特

即`bit`，二进制数的缩写，比特是计算机科学中的基本信息单位，表示具有两个值之一的状态，通常为`0`和`1`。
从最基础的层面来看，存储在计算机中的任何数据都以`bit`表示

## 字节

即`byte`，一组八位，例如`01101001`是一个字节。一个字节最多可以表示`256`个数据值（2<sup>8</sup>）

由于二进制数是仅用两个符合表示的数字，因此一个字节可以有效地以二进制格式表示`0`到`255`之间的所有数字

```
1: 00000001
2: 00000010
3: 00000011
4: 00000100
```

## 固定位宽整数

由固定位数表示的整数，如 32 位整数是 32 位（4 字节）表示的整数，64 位整数是 64 位（8 字节）表示的整数

以下是数字 1 的 32 位表示形式，具有明显分隔的字节

```
00000000 00000000 00000000 00000001
```

以下是数字 10 的 64 位表示形式，具有明显分隔的字节

```
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010
```

## 内存

从广义上来看，内存是计算机的基础，所有的数据都存储在其中。在算法面试中，重要的是要注意以下几点：

- 存储在内存中的数据以字节存储，进而以位存储
- 内存中的字节可以“指向”内存中的其它字节，从而存储对其它数据的引用
- 机器的内存量是有限的，因此限制算法占用的内存量非常有价值
- 访问一个字节或固定数量的字节（如 32 位和 64 位整数的 4 个字节或 8 个字节）是一种基本操作，可以简单地视为单个操作单元

## 复杂度

假设有一个整数数组，数组内有`N`个整数，现在有三个方法用来处理这个数组，这三个方法的分别是

1. 简单返回数组第一个元素加上 1

```
F(1) = 1 + a[0]
```

2. 求所有元素相加的和并返回

```
F(2) = sum(a)
```

3. 将数组排成逐个元素相关联的阵列并返回（排列组合），如传入`[1, 2, 3]`则返回`[1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 3, 3, 1, 3, 2, 3, 3]`

```
F(3) = peri(a)
```

首先看变化的是数组的元素个数`N`，随着`N`不断趋于无穷大，三个方法处理的时间也慢慢增加，三个方法的时间复杂度可以分别表示为

1. F(1) = O(1)
2. F(2) = O(N)
3. F(3) = O(N<sup>2</sup>)

第三个方法因为需要对每个元素按`N`的数量排列`N`次，故为`N * N`次，也就是`N`的平方

复杂度可能有非常多的表示方法，按如

- 常数：O(1)
- 线性：O(N)
- 对数：O(log(N))
- 对数线性：O(N \* log(N))
- 二次方：O(N<sup>2</sup>)
- 立方：O(N<sup>3</sup>)
- 指数：O(2<sup>N</sup>)
- 阶乘：O(N!)

当分析一个复杂度时，如果复杂度表达式里面的存在常量，或变化较小的量时，是可以忽略掉的，如 O(N<sup>2</sup> + N + 1) 中的 N + 1 是可以忽略的，
因为相对于 N<sup>2</sup> 来说，N + 1 的变化太小了。再比如 O(N<sup>2</sup> + log(N) + 2N + 3) 中，
2N + 3 是可以忽略的。这其实是算是数学中的公式简化，但又不是特别的严谨

在算法复杂度分析中 log(N) 表示以 2 为底 N 的对数，如 N=32，则 log(32)=5，即 2<sup>5</sup>=32，与数学中不写底数则以 10 为底的默认表示有区别。
随着 N 不断翻倍增长，log(N)的值变化也是相对较小的

比如有一个算法，接收一个数组作为参数，每次循环执行时都将数组一分为二，直到只剩下一个元素，那么这个算法的复杂度就是 O(log(N))，
N 表示输入数组的元素个数，当数组为 8 个元素时，算法循环 3 次，当数组元素为 16 个时，算法循环 4 次，以此类推

还有另一种 log(N)的表示方式，平衡二叉树寻找，每次只能选择一个子节点，左边或右边，如果选择了左边，则右边的节点就不会再被访问到，
如此选择一直到树的末尾，随着树的层级越来越深，子节点越来越多，以 N 表示树中的节点数量，则每次做出选择的次数就可以近似的表示为 log(N)

## 数组（Arrays）

必须占用连续的内存空间，随机访问较快，索引从 0 开始，N 表示元素数量

- 初始化 O(N) ST
- 访问指定索引的值 O(1) ST
- 更新指定索引的值 O(1) ST
- 在开头插入一个值 O(N)
- 在中间插入一个值 O(N)
- 在末尾插入一个值
  - 动态数组 O(1)
  - 静态数组 O(N)
- 遍历 O(N) T, O(1) S
- 复制 O(N) ST
- 在开头删除一个值 O(N)
- 在中间删除一个值 O(N)
- 删除最后一个值 O(1)
- 随机位置添加
  - 静态数组 O(N) T, O(1) S
  - 动态数组，有两种情况，第一种是容量足够时 O(1) T, O(1) S，第二种是触发了容量扩充 O(N) ST

> S 表示空间复杂度，T 表示时间复杂度

## 链表（Linked Lists）

不要求连续的内存空间，随机访问较慢，i 表示索引（从 0 开始），N 表示元素数量

- 初始化 O(N) ST
- 读取 O(i) T, O(1) S
- 修改 O(i) T, O(1) S
- 复制 O(N) ST
- 遍历 O(N) T, O(1) S

## 哈希表（Hash Tables）

以键值对存储数据，通过散列函数计算键的并按其计算结果来存储值，以保证下次访问时无需比较即可直接获得该键对应的值。由于哈希表的特性，
操作元素的时间复杂度在一般情况下都是 O(1) T，空间复杂度是 O(N) S。最坏的情况下，存在键冲突需要解决，则时间复杂度为 O(N)

## 栈和队列（Stacks And Queues）

栈为先进后出（LIFO），队列为先进先出（FIFO），两者的中间数据都不允许访问，所以只要符合它们的特性，底层可以使用动态数组或链表来作为存储结构的实现，
N 表示元素数量，一般情况下，它们的复杂度表示为 O(1) ST，如果需要搜索元素，则复杂度为 O(N) T, O(1) S

## 字符串（Strings）

实际上字符串是一个不可变的结构，内部是一个字符数组，如果对字符串进行修改则需要重新申请内存空间并将源数据和新数据拷贝到新的空间，N 表示字符数量

- 遍历 O(N) T, O(1) S
- 拷贝 O(N) ST
- 读取 O(1) ST

> 小部分语言中字符串是可变的，如 C++

## 图（Graphs）

一个由节点和边组成的数据结构，一个节点可以有任意的边，每条边可以单向的也可以是双向的，V 表示节点数量，E 表示边的数量，
空间复杂度为 O(V+E)，时间复杂度为 O(V+E)

## 树（Trees）

由一个根节点通过边连接子节点并且子节点也可以拥有子节点，类似一颗倒过来的树一样的数据结构，N 表示节点数量，
一般情况下空间复杂度为 O(N) S，时间复杂度为 O(N) T

- 满二叉树，一个节点要么是叶子节点，要么是包含有左右子树的节点
- 完全二叉树，设二叉树的深度为 k，除第 k 层外，从第 1 层到 k-1 层的结点数都达到最大个数，第 k 层所有的结点都连续集中在最左边
- 平衡二叉树，它或是一颗空树，或它的左子树和右子树的深度之差（平衡因子）的绝对值不超过 1，且它的左子树和右子树都是一颗平衡二叉树
- 霍夫曼树（Huffman Tree），树的带权路径长度达到最小
- 二叉查找树，左子节点总是比父节点小，右子节点总是比父节点大
- 红黑树，可以自平衡的二叉查找树

Last Modified 2022-03-09
