# 数据结构

## 比特

即`bit`，二进制数的缩写，比特是计算机科学中的基本信息单位，表示具有两个值之一的状态，通常为`0`和`1`。
从最基础的层面来看，存储在计算机中的任何数据都以`bit`表示

## 字节

即`byte`，一组八位，例如`01101001`是一个字节。一个字节最多可以表示`256`个数据值（2<sup>8</sup>）

由于二进制数是仅用两个符合表示的数字，因此一个字节可以有效地以二进制格式表示`0`到`255`之间的所有数字

```
1：00000001
2：00000010
3：00000011
4：00000100
```

## 固定位宽整数

由固定位数表示的整数，如 32 位整数是 32 位（4 字节）表示的整数，64 位整数是 64 位（8 字节）表示的整数

以下是数字 1 的 32 位表示形式，具有明显分隔的字节

```
00000000 00000000 00000000 00000001
```

以下是数字 10 的 64 位表示形式，具有明显分隔的字节

```
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010
```

## 内存

从广义上来看，内存是计算机的基础，所有的数据都存储在其中。在算法面试中，重要的是要注意以下几点：

- 存储在内存中的数据以字节存储，进而以位存储
- 内存中的字节可以“指向”内存中的其它字节，从而存储对其它数据的引用
- 机器的内存量是有限的，因此限制算法占用的内存量非常有价值
- 访问一个字节或固定数量的字节（如 32 位和 64 位整数的 4 个字节或 8 个字节）是一种基本操作，可以简单地视为单个操作单元

## 复杂度

假设有一个整数数组，数组内有`N`个整数，现在有三个方法用来处理这个数组，这三个方法的分别是

1. 简单返回数组第一个元素加上 1

```
F(1) = 1 + a[0]
```

2. 求所有元素相加的和并返回

```
F(2) = sum(a)
```

3. 将数组排成逐个元素相关联的阵列并返回（排列组合），如传入`[1, 2, 3]`则返回`[1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 3, 3, 1, 3, 2, 3, 3]`

```
F(3) = peri(a)
```

首先看变化的是数组的元素个数`N`，随着`N`不断趋于无穷大，三个方法处理的时间也慢慢增加，三个方法的时间复杂度可以分别表示为

1. F(1) = O(1)
2. F(2) = O(N)
3. F(3) = O(N<sup>2</sup>)

第三个方法因为需要对每个元素按`N`的数量排列`N`次，故为`N * N`次，也就是`N`的平方

复杂度可能有非常多的表示方法，按如

- 常数：O(1)
- 线性：O(N)
- 对数：O(log(N))
- 对数线性：O(N \* log(N))
- 二次方：O(N<sup>2</sup>)
- 立方：O(N<sup>3</sup>)
- 指数：O(2<sup>N</sup>)
- 阶乘：O(N!)

当分析一个复杂度时，如果复杂度表达式里面的存在常量，或变化较小的量时，是可以忽略掉的，如 O(N<sup>2</sup> + N + 1) 中的 N + 1 是可以忽略的，
因为相对于 N<sup>2</sup> 来说，N + 1 的变化太小了。再比如 O(N<sup>2</sup> + log(N) + 2N + 3) 中，
2N + 3 是可以忽略的。这其实是算是数学中的公式简化，但又不是特别的严谨

在算法复杂度分析中 log(N) 表示以 2 为底 N 的对数，如 N=32，则 log(32)=5，即 2<sup>5</sup>=32，与数学中不写底数则以 10 为底的默认表示有区别。
随着 N 不断翻倍增长，log(N)的值变化也是相对较小的

比如有一个算法，接收一个数组作为参数，每次循环执行时都将数组一分为二，直到只剩下一个元素，那么这个算法的复杂度就是 O(log(N))，
N 表示输入数组的元素个数，当数组为 8 个元素时，算法循环 3 次，当数组元素为 16 个时，算法循环 4 次，以此类推

还有另一种 log(N)的表示方式，平衡二叉树寻找，每次只能选择一个子节点，左边或右边，如果选择了左边，则右边的节点就不会再被访问到，
如此选择一直到树的末尾，随着树的层级越来越深，子节点越来越多，以 N 表示树中的节点数量，则每次做出选择的次数就可以近似的表示为 log(N)

## 数组（Arrays）

必须占用连续的内存空间，随机访问较快，索引从 0 开始，N 表示元素数量

以下是数组的标准操作及其对应的时间复杂度:

- 访问给定索引处的值：O(1)
- 更新给定索引处的值：O(1)
- 在开头插入-一个值：O(n)
- 在中间插入一个值：O(n)
- 在末尾插入一个值:
  - 处理动态数组时的摊销 O(1)
  - 处理静态数组时的 O(n)
- 在开头删除一 个值：O(n)
- 删除中间的值：O(n)
- 最后删除一个值：O(1)
- 复制数组：O(n)

静态数组是数组的一种实现，它分配固定数量的内存用于存储数组的值。因此，将值附加到数组涉及复制整个数组并为其分配新内存，从而考虑新附加值所需的额外空间。这是一个线性时间操作。

动态数组是数组的一种实现，它预先分配存储数组值所需的内存量的两倍。将值附加到数组是一个恒定时间操作，直到分配的内存被填满，此时数组被复制并再次为其分配双倍内存。这种实现导致了一个摊销的固定时间插入操作。

许多流行的编程语言（如 JavaScript 和 Python）将数组实现为动态数组。

## 链表（Linked Lists）

不要求连续的内存空间，随机访问较慢，i 表示索引（从 0 开始），N 表示元素数量

### 单链表（Singly Linked List）

一种由节点组成的数据结构，每个节点都有一些值和指向链表中下一个节点的指针。链表节点的值和下一个节点通常分布存储在`value`和`next`属性中。

链表中的第一个节点称为链表的头，而链表中的最后一个节点，其`next`属性指向空值，被称为链表的尾部。

下面是一个单链表的可视化表示，其节点包含整数值：

```
0 -> 1 -> 2 -> 3 -> 4 -> 5 -> null
```

单链表通常将其头部暴露给用户以便于访问。虽然在单链表中查找节点涉及遍历通向相关节点的所有节点（与使用数组的即时访问相反），但添加或删除节点仅涉及覆盖下一个指针（假设您可以访问要添加或删除的节点之前的节点）。

以下是单链表的标准操作及其对应的时间复杂度:

- 访问头部：O(1)
- 访问尾部：O(n)
- 访问中间节点：O(n)
- 插入/移除头部：O(1)
- 插入/移除尾部：O(m) 访问 + O(1) 操作
- 插入/移除中间节点：O(n) 访问 + O(1) 操作
- 搜索值：O(n)

### 双向链表（Doubly Linked List）

与单链表类似，只是双向链表中的每个节点也有一个指向链表中前一个节点的指针。前一个节点通常存储在一个`prev`属性中。

与单链表类似，双向链表中最后一个节点的`next`指向一个空值，而双向链表的表头`prev`也是指向一个空值的，用以表示开头。

下面是一个双向链表的可视化表示，其节点保存整数值：

```
null <- 0 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5 -> null
```

虽然双向链表通常向其用户公开它的头和尾，而不是在单链表的情况下只向用户公开它的头，但它在其他方面的行为与单链表非常相似。

以下是双向链表的标准操作及其对应的时间复杂度：

- 访问头部：O(1)
- 访问尾部：O(1)
- 访问中间节点：O(n)
- 插入/移除头部：O(1)
- 插入/移除尾部：O(1)
- 插入/移除中间节点：O(n) 访问 + O(1) 操作
- 搜索值：O(n)

### 循环链表（Circular Linked List）

一个没有明确头尾的链表，因为它的"尾"指向它的"头"，有效地形成了一个封闭的圆圈。循环链表可以是单循环链表，也可以是双循环链表。

## 哈希表（Hash Tables）

一种提供快速插入、删除和查找键/值对的数据结构。

在底层，哈希表使用基于链表的动态数组来有效地存储键/值对。插入键/值对时，哈希函数首先将键（通常是字符串（或任何可以哈希的数据，取决于哈希表的实现））映射到整数值，并扩展为底层动态数组中的索引。然后，与键关联的值被添加到存储在动态数组中该索引处的链表中，并且对键的引用也与该值一起存储。

哈希表依靠高度优化的哈希函数来最小化存储值时发生的冲突数量：两个键映射到同一个索引的情况。

下面是一个哈希表的例子：

```
[
  0: (value1, key1) -> null
  1: (value2, key2) -> (value3, key3) -> (value4, key4)
  2: (value5, key5) -> null
  3: (value6, key6) -> null
  4: null
  5: (value7, key7) -> (value8, key8)
  6: (value9, key9) -> null
]
```

在上面的哈希表中，键 key2、key3 和 key4 发生冲突，都被哈希为 1，键 key 7 和 key8 发生冲突，两者都被哈希为 5。

以下是哈希表的标准操作及其对应的时间复杂度：

- 插入键/值对：平均 O(1)；O(n) 在最坏的情况下
- 删除键/值对：平均 O(1)；O(n) 在最坏的情况下
- 查找键：平均 O(1)；O(n) 在最坏的情况下

最坏情况的线性时间操作发生在哈希表遇到大量冲突时，导致内部链表很长，需要 O(n) 时间来遍历。

然而，在实践中，尤其是在算法面试中，我们通常假设哈希表使用的哈希函数经过优化，以至于冲突极为罕见，并且几乎可以保证恒定时间的操作。

## 栈和队列（Stacks And Queues）

### 栈

一种类似数组的数据结构，其元素遵循 LIFO 原则：Last In, First Out。

通常可以用桌面上的一摞书来比较：最后一本放在这一摞书中的书是第一本优先被拿走的书

以下是栈的标准操作及其对应的时间复杂度

- 将元素压入栈中：O(1)
- 从栈中弹出一个元素：O(1)
- 查看栈顶元素：O(1)
- 在栈中搜索元素：O(n)

栈通常使用动态数组或者单链表来实现

### 队列

一种类似数组的数据结构，其元素遵循 FIFO 原则：First In, First Out。

队列通常可以比作一群人在商店排队购买商品：第一个排队的人是第一个购买完商品并离开的人

以下是栈的标准操作及其对应的时间复杂度

- 将元素加入队列：O(1)
- 从队列中取出一个元素：O(1)
- 查看队列前面的元素：O(1)
- 在队列中搜索元素：O(n)

队列通常使用双向链表实现

## 字符串（Strings）

作为计算机科学中的基本数据类型之一，字符串作为整数数组存储在内存中，其中给定字符串中的每个字符都通过一些字符编码标准 (如 ASCI)映射到整数。

字符串的行为很像普通数组，主要区别在于，在大多数编程语言中(C++ 是一个明显的例外) ，字符串是不可变的，这意味着它们在创建后无法编辑。这也意味着像将字符附加到字符串这样的简单操作比它们看起来更昂贵。

由于字符串不变性而看似昂贵的操作的典型示例如下:

```
string = "this is a string"
newString = ""

for character in string:
    newString += character
```

上述操作的时间复杂度为 O(n<sup>2</sup>)，其中 n 表示字符数量，因为每增加个字符新字符串创建一个全新的字符串，它本身就是一个 O(n) 操作。因此，执行了 n 个 O(n) 操作，从而导致总体上 O(n<sup>2</sup>) 的时间复杂度操作。

## 图（Graphs）

可能相关的称为顶点的节点或值的集合；顶点之间的关系称为边。一般情况下空间复杂度为 O(V + E) S，时间复杂度为 O(V + E) T。

生活中的很多事情都可以用图表来表示；例如，一个社交网络可以用一个图来表示，它的顶点是用户，其边是用户之间的友谊。类似地，城市地图可以用一个顶点为的图来表示城市中的位置，其边是位置之间的道路。

### 循环图

简单地说，当图中的三个或三个以上的顶点连接起来形成一个闭环时，图中就出现了一个循环。请注意，图循环的定义有时会扩大到包括长度为 2 或 1 的循环；在编码的背景下面试中，在处理涉及图形循环的问题时，重要的是要弄清楚究竟是什么构成了一个循环。

### 有向图

一种图，其边是有向的，这意味着它们只能在一个指定的方向上遍历。

例如，机场和航班的图表可能会被定向，因为航班专门从一个机场飞往另一个机场（即，它有一个方向），不一定意味着存在相反方向的飞行。

### 无向图

边是无向的图，这意味着它们可以在两个方向上遍历。例如，朋友关系的图可能是无向的，因为友谊本质上是双向的。

### 连通图

如果对于图中的每一对顶点，都有一条由一条或多条边连接给定顶点的路径，则该图是连通的。
在有向图的情况下，该图是：

- 如果每对顶点的顶点之间存在双向连接（即，对于每个顶点对 (u, v) 可以从 u 到达 v 也可以从 v 到达 u）
- 如果每对顶点的顶点之间存在连接（但不一定是双向连接），则为弱连接

## 树（Trees）

一种由节点组成的数据结构，每个节点都有一些值和指向子节点的指针，这些节点在树中递归地形成子树。

树中的第一个节点称为树的根，而树底部的节点（没有子节点的节点）被称为叶节点或简称为叶。树的根和叶子之间的路径称为树枝，树的高度是它最长的树枝的长度。树节点的深度是它到树根的距离；这也被称为节点在树中的层级。

树实际上是一个连接的、有向的和无环的图，它有一个明确的根节点，并且它的节点都有一个父节点（根节点除外，它实际上没有父节点）。请注意，在大多数树的实现中，树节点没有指向他们的父母，但如果需要，他们可以。

有许多类型的树和树状结构，包括二叉树、堆和字典树。

### 二叉树

一棵树，其节点最多有两个子节点。二叉树的结构使得它的许多操作都具有对数时间复杂度，这使得二叉树成为非常有吸引力和常用的数据结构。

### K-ary 树

一棵树，其节点最多有 k 个子节点。二叉树是 k-ary 树，其中 k == 2。

### 完美二叉树

一棵二叉树，其内部节点都具有两个子节点，并且其叶节点都具有相同的深度。例子：

```
           1
      /         \
     2           3
   /   \       /   \
  4     5     6     7
 / \   / \   / \   / \
8   9 10 11 12 13 14 15
```

### 完整二叉树

一棵几乎完美的二叉树；它的内部节点都有两个子节点，但它的叶子节点不一定都有相同的深度。此外，完整二叉树的最后一层中的节点尽可能靠左。例子：

```
          1
       /     \
      2       3
    /   \   /   \
   4     5 6     7
 /   \
8     9
```

相反，下面的二叉树是不完整的，因为它最后一层的节点不是尽可能的靠左：

```
        1
    /      \
   2        3
 /   \    /   \
4     5  6     7
       /   \
      8     9
```

### 平衡二叉树

一棵二叉树，其节点都具有高度相差不超过 1 的左右子树。平衡二叉树是这样的，它的操作时间复杂度保持为 log(N)。

例如，在以下不平衡二叉树的左子树的底部插入一个节点显然不是 log(N) 的时间操作，因为它将涉及遍历大多数树的节点：

```
             1
          /     \
         2       3
       /
      4
    /
   8
  /
10
```

下面是一个平衡二叉树的例子：

```
          1
       /     \
      2       3
    /   \   /   \
   4     5 6     7
 /   \         /
10    9       8
```

### 满二叉树

一棵二叉树，其节点都具有两个子节点或零个子节点。例子：

```
    1
 /     \
2       3
      /   \
     6     7
   /   \
  8     9
```

Last Modified 2022-05-01
