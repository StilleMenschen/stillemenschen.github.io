# 设计：Tinder

## 澄清要问的问题

- **问：据我所知，在 Tinder 上注册的用户首先会创建个人资料（姓名、年龄、工作、简历、性取向等），之后他们可以开始在他们附近的其他用户资料间滑动，这些用户出现在应用程序主页上堆叠的潜在匹配项。如果两个用户向右滑动，他们就会相互匹配，他们现在可以直接相互交流。我们是在设计这一切吗？**

  答：可以，但您不必设计消息传递功能或在两个用户匹配后可用的任何功能。您还应该设计超级喜欢功能和撤销功能。超级喜欢允许用户有效地到达另一个用户的牌组顶部，表明他们超级喜欢他们。撤消允许用户取消滑动他们上一次滑动的用户。因此，如果他们不小心在某人身上向左滑动，他们可以撤消该操作。但这只能对最后一个用户进行；你不能连续撤消。

- **问：关于撤消功能，用户可以撤消匹配吗？**

  答：为了这个设计，我们只允许在您向左滑动时撤消，而不是在您向右滑动时。如果您向左滑动，然后向右滑动，您将无法再从两次滑动之前撤消向左滑动。

- **问：用户每天的向右滑动、超级喜欢和撤消次数是否有限？他们牌组中潜在匹配的数量如何？该数字是否有每日上限，例如每天 100 或 200 个潜在匹配？**

  答：为了这个设计，我们不要有任何限制。换句话说，用户将在他们的牌组中获得无限数量的潜在匹配项（在他们的距离参数内），他们可以无休止地向右滑动它们，超级喜欢它们，并撤消向左滑动。自然地，如果用户要在他们的距离参数内浏览每一个潜在的匹配项，那么他们将用完潜在的匹配项，但随着新用户在 Tinder 上注册，他们的牌组可能会很快获得新的潜在匹配项。

- **问：关于潜在匹配的牌组，以下是我所做的一些假设；让我知道这听起来是否合适。正如我们刚刚提到的，每个用户都有无穷无尽的潜在匹配，这些匹配在他们的距离参数范围内，并且应该以某种方式对这些匹配进行排序（可能基于匹配性分数）。卡片组应该只包含已经喜欢此用户或尚未刷过他们的用户。对于已经在主用户上向左滑动的用户，我们可能应该尽最大努力尝试将其从主用户的牌组中删除。当然，超级喜欢主要用户的用户应该排在最前面。这看起来合理吗？**

  答：这看起来很合理，但你实际上不需要担心牌组是如何生成的。换句话说，您可以假设我们有一个智能匹配算法，可以根据匹配性分数、偏好、距离等为您生成牌组，您应该只是依赖该算法并找出它在设计方案中合适的位置。因此，您甚至不必担心在用户向左滑动的潜在匹配是否会出现在用户的牌组中；匹配算法会为您解决这个问题。

- **问：我们是否需要设计系统中用户有新的匹配项时通知他们的这一部分？**

  答：您应该考虑如果实时产生匹配，当用户向右滑动另一个用户时，将如何通知用户已经匹配。否则，当用户停留在应用程序不做操作或着根本不使用应用程序时，不需要担心匹配通知系统。

- **问：就规模而言，我们为多少用户设计 Tinder，我们应该假设他们位于世界的哪个地方？**

  答：假设我们在 Tinder 上有大约 5000 万用户。您可以假设它们在全球范围内均匀分布，可能在主要城市地区有较多的集中。

- **问：就延迟和可靠性而言，我假设我们希望 Tinder 在很大程度上具有高可用性，并且我们希望左右滑动感觉是即时性的。如果您第一次打开应用程序时或在您刷过 200 个牌组后有一点加载时间，是否可以？**

  答：您对延迟的描述非常好。就可靠性而言，为了这个设计，我们不要太担心它。你可以假设你有一个开箱即用的高可用性 SQL 配置，而不用担心可用性细节。

## 1 收集系统要求

与任何系统设计面试问题一样，我们要做的第一件事就是收集系统需求；我们需要弄清楚我们正在构建什么系统。

我们正在设计 Tinder 背后的核心系统，它允许用户创建个人资料并在看似无穷无尽的潜在匹配中滑动。用户还可以超级喜欢潜在的匹配项，将自己置于其他用户牌组的顶部，如果是向左滑动，他们可以撤消最近的滑动。用户每天可以进行的滑动、超级喜欢和撤消的次数没有任何限制。

我们明确没有设计任何在两个用户匹配后可用的功能，包括任何类型的通知系统来提醒用户他们已经匹配，除非向右滑动时与潜在匹配项产生匹配。

我们的系统应该为大约 5000 万全球用户群提供服务，这些用户均匀分布在世界各地，我们希望大多数情况下都具有即时滑动，允许在 Tinder 应用程序首次加载时以及用户在用户刷过了很多潜在的匹配项时存在一定的加载延迟。

我们被告知不需要太过关注系统的可用性，这应该有助于我们缩小设计范围。

## 2 制定计划

我们将通过将其分为四个主要部分来解决这个系统：

- 存储概述
- 用户资料创建
- 牌组生成
- 浏览牌组

我们将在最后介绍超级喜欢和撤消，这可能涉及对我们的滑动牌组设计进行调整。

## 3 存储概述

我们期望存储的大多数数据（用户资料、牌组、滑动和匹配）都具有结构化意义，因此我们将为其使用 SQL 存储解决方案，并将直接从相关的 SQL 表中提供服务。

所有这些数据都将存储在区域数据库中，根据用户较集中的地区（例如，北美东海岸的数据库，北美中部的一个数据库，西欧的一个数据库，印度的一个数据库等），以及用户在通过一些循环负载均衡路由到中间 API 服务器后，获取 Tinder 数据将自动路由到最近的区域数据库。

唯一的例外是用户的个人资料图片，我们将其存储在全局 blob 存储中，并将通过 CDN 提供服务。

我们将在区域数据库之间进行一些异步复制，这需要几分钟到几小时的时间。复制的异步性应该没问题，因为根据应用程序的性质，用户与之交互的人通常会与他们距离相近，因此会使用到与他们相同的区域数据库。

## 4 用户资料创建

我们将 Tinder 用户信息存储在一个单独的 SQL 表中，其中每一行将代表一个用户信息：

- userId: string, 唯一性的用户 ID
- geolocation: point, 地理位置
- name: string
- age: int
- gender: enum
- sexualPreference: enum
- job: string
- bio: string
- pictures: string[], blob 存储地址

userId 字段将自动分配给用户，而大多数其他字段将由用户在创建或编辑其个人资料时设置。用户的地理位置可以在用户打开 Tinder 应用程序并且与存储在其个人资料中的位置不同的位置时随时更新。

假设有 5000 万用户，每个用户资料的估计上限约为 2KB（不包括图片），我们将需要每个区域 2KB \* 50000000 = 100GB 的存储空间，或者总共需要 1-5TB，假设有 10-50 个区域数据库。这是非常小的存储空间。

就图片而言，我们可以假设用户平均每人拥有五张图片，每张图片的上限约为 2MB（高质量，1920x1080p）。我们几乎肯定会想要减小图片的尺寸，因为它们只能在小型移动屏幕上查看，并且我们将对它们执行一些有损压缩，因为我们可以承受损失一点质量。我们可以假设这会将图片降低到每张图片大约 50KB（降低分辨率后约为 200-500KB，有损压缩后约为 50KB）。

```
~50KB * 5 = 250KB 每个用户的图片
~250KB * 50000000 个用户 = 12.5TB（不是很多）
```

显然，图片预估大小满足我们大部分的存储需求。

## 5 牌组生成

对于牌组生成，我们将让我们的智能牌组生成算法每天为每位用户持续生成包含 200 个潜在匹配项的牌组。这将确保当用户与其交互时，用户牌组尽可能相关。例如，如果某人离开某个位置并因此不再与特定用户相关，则他们将在一天内从用户的牌组中删除，从而最大限度地减少用户看到不相关个人资料的机会。

牌组生成算法可以足够聪明，不会为超过一天不活动的用户重新生成牌组，它也可以被告知为刚刚改变位置的用户重新生成牌组（即，当用户打开 Tinder 应用程序并位于与其个人资料中存储的位置不同的位置，该应用程序告诉牌组生成算法为用户重新生成牌组）。

我们会将每个用户的潜在匹配组存储在一个单独的 SQL 表中，其中每一行代表一个组：

```
userId: string , 这个 deck 所属的用户 id
potentialMatches: string[] , userIds 列表
```

在应用程序加载时，Tinder 应用程序将请求其牌组前 40 个用户资料，将它们从牌组中移除（通过更新牌组表中牌组的行），并在本地存储它们。值得注意的是，如果我们在创建用户资料时没有压缩用户资料图像，每个用户将请求并尝试存储越 400MB （2MB \* 5 \* 40）的数据，这将会是庞大的数据量。但通过我们的压缩，每张图片约为 50KB，40 个用户资料仅变成 10MB 的数据，这是可以接受的。

还值得注意的是，如果用户关闭手机或完全关闭 Tinder 应用程序进程，则用户没有刷过的任何本地存储的用户资料都将在稍后被牌组生成算法简单地读取到他们的牌组，因为它们可能是相关的个人资料，并且尚未被用户浏览过。

Tinder 应用程序将确保本地缓存的用户资料数量永远不会低于 20，这样用户几乎不会觉得他们的用户资料牌组已经浏览完。为了实现这一点，当用户还剩下 20 个本地存储的用户资料时，用户的手机会快速地从他们的牌组获取前 20 个额外的用户资料。

当用户用完潜在匹配时（即他们的牌组已从 200 个潜在匹配项变为 0 个），对另外 20 个用户资料的请求会触发按需生成新牌组。这是唯一一次我们可能会在使用应用程序的过程中预期一些潜在的加载时间，但这种情况很少发生，因为用户必须在一天内滑动 200 个潜在匹配项，并且必须非常快速地向右滑动才能在生成新牌组之前检查他们最后的 20 个用户资料。

## 6 滑动浏览牌组

对于滑动浏览牌组，我们将有另外两张 SQL 表：一张用于浏览牌组，一张用于匹配。浏览牌组的 SQL 表如下所示：

- swiperId: string, 执行滑动的用户的 id
- swipeeId: string, 已经浏览过的用户 id
- swipeType: enum (LIKE, PASS), 滑动操作类型（喜欢、跳过）
- timestamp: datetime

该表将在 swipeeId 和 timestamp 上建立索引，以便快速查找用户最近的滑动（对用户执行的所有最近的滑动）。

匹配的 SQL 表如下所示：

- userOneId: string, 匹配的第一个用户的 id
- userTwoId: string, 匹配的第二个用户的 id
- timestamp: datetime

该匹配表将主要用于超出本题范围的系统部分。

在应用程序加载时，Tinder 应用程序将获取 swipes 表中 swipeeId 与用户的 userId 匹配的所有行。然后，每 30 秒，它将获取相同的行，除了那些时间戳在最近一次获取的滑动时间戳之后的行。

Tinder 应用程序会将所有滑动保存在内存中，采用类似哈希表的结构，这意味着对于任何潜在的匹配，应用程序可以立即知道它们是否已经在被用户滑动浏览过。这些数据可以轻松放入手机的内存中（每次滑动约 20 字节 \* 最多 10 万次滑动 = 2MB）。

当用户滑动时，应用程序会将滑动浏览记录写入滑动浏览记录表。如果滑动操作是 LIKE，后端将检查匹配的滑动，如果存在，它会将匹配写入匹配表。

在应用程序方面，如果有匹配项（由于本地缓存的滑动浏览操作时可以立即知晓），应用程序将向用户显示通知；这是即时的，因为我们不依赖后端的响应。

## 7 超级喜欢

Super Like 功能可以通过对我们现有系统的以下调整来实现：

1. 一个新的 SUPER-LIKE 值被添加到 swipes 表中 的 swipeType。
2. 当用户（Foo）超级喜欢潜在匹配项（Bar）时，记录的滑动设置为 SUPER-LIKE。如果后端发现匹配，除了将匹配写入匹配表之外，不会发生任何其他事情。否则，后端将 Foo 的 userId 写入 Deck 表中 Bar 的牌组中，将 Foo 放在 Bar 的牌组顶部，在其他超级喜欢之后，因为较旧的超级喜欢具有优先权。如果 Foo 的 userId 已经在 Bar 的牌组中，它就会被移动到前面。

我们的牌组生成算法足够智能，可以将超级喜欢放在牌组前面，按时间戳排序，这样较旧的超级喜欢会首先出现。

就 Tinder UI 而言，当用户牌组前面的潜在匹配已经超级喜欢该用户（由于本地缓存的滑动浏览记录可以立即知晓）时，会显示一个视觉指示器。如果用户在应用程序上被尚未获取个人资料的用户（即不在本地存储的 20-40 个个人资料中的用户）超级喜欢，则只要应用程序获取他们的牌组中下一组 20 个用户资料，他们会在看到超级喜欢的用户。

## 8 撤消

撤消功能可以通过简单地将原本在左滑动时的 API 调用延迟到下一次滑动操作或直到 Tinder 应用程序关闭来实现。这避免了对 swipes 表进行多次写入，否则需要这样做才能撤消向左滑动。

## 9 系统架构图

![架构图](images/tinder-system-diagram.svg)

Last Modified 2022-04-05
