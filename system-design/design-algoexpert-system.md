# 设计：算法专家系统

## 澄清要问的问题

- **问：我们是在设计整个 AlgoExpert 平台还是只是其中的特定部分，比如编码工作区？**

  答：由于我们只有 45 分钟左右，所以你应该设计 AlgoExpert 平台的核心用户流程。核心用户流程包括用户登陆网站主页、进入问题列表、将问题标记为完成或进行中，然后为每种语言编写和运行各种语言的代码。不用担心付款或身份验证；您可以假设您已经拥有这些服务（顺便说一下，我们这里主要依赖第三方服务，例如 Stripe、PayPal 和 OAuth2）。

- **问：AlgoExpert 看起来不像是最关键的系统（如医院系统或飞机软件）；我们可以接受`99%`到`99.9%`的系统可用性吗？**

  答：是的，无需过多关注使系统具有高可用性。

- **问：我们应该为多少客户构建此系统？AlgoExpert 的受众是全球性的还是仅限于一个国家？**

  答：AlgoExpert 的网站每个月接收数十万用户，并且随时可能有数万用户在使用网站。我们希望该网站对世界各地的人们都开放，而北美和印度是该平台特别希望迎合的两大市场。

- **问：AlgoExpert 是否经常更改其内容（问题列表和问题解决方案）？**

  答：是的 —— 平均每两天一次。我们希望在一小时内将我们的变更反映在全球的服务中。

- **问：我们应该设计多少编码工作区背后的代码执行引擎？我们是否必须担心在我们的服务器上运行随机用户代码的安全性？**

  答：您可以忽略代码执行引擎安全方面的问题，而只关注其核心功能 —— 在任何给定时间以可接受的延迟运行各种语言的代码的能力。

- **问：虽然我们会关心整个系统的延迟，但代码执行引擎似乎是我们最关心的地方，因为它非常具有交互性，而且它似乎也是我们系统中最难支持的部分；我们可以接受 1 到 3 秒的平均运行代码延迟吗？**

  答：是的 —— 从产品的角度来看，这似乎是合理且可以接受的。

## 1 收集系统要求

与任何系统设计面试问题一样，我们要做的第一件事就是收集系统需求；我们需要弄清楚我们正在构建什么系统。

根据我们对澄清问题的回答（请参阅问答部分），我们正在构建核心 AlgoExpert 用户流程，其中包括用户登陆网站、访问问题、将其标记为完成、编写代码、运行代码以及保存编写好的代码。

我们不需要担心付款或身份验证，也不需要深入了解代码执行引擎。

我们正在为全球用户构建这个平台，重点是北美和印度用户，我们不需要过度优化我们系统的可用性。我们可能不需要超过`99%`或`99.9%`，因为我们没有建立健康或安全系统，这使我们每年有 8 小时到 3 天的停机时间，这是合理的。总而言之，这意味着我们无需过多担心可用性。

我们在合理的范围内关心延迟和吞吐量，但除了代码执行引擎之外，这似乎不是我们系统的一个特别困难的方面。

## 2 制定计划

重要的是要将必要的信息组织起来，并就我们将如何处理我们的设计制定一个清晰的计划。我们的系统有哪些主要的、可区分的组件？

一方面，AlgoExpert 有很多静态内容；例如，整个主页是静态的，并且有很多图片。另一方面，AlgoExpert 不仅仅是一个静态网站；它显然有很多用户自己可以生成的动态内容（例如，他们可以编写的代码）。所以我们需要一个强大的 API 来支持我们的 UI，并且鉴于用户内容保存在网站上，我们还需要一个数据库来支持我们的 API。

我们可以将我们的系统分为 3 个核心组件：

- 静态 UI 内容
- 访问问题并与之交互（问题完成状态、保存解决方案等）
- 运行代码的能力

请注意，第二个要点可能会进一步划分。

## 3 静态 UI 内容

对于 UI 静态内容，我们可以将图片和 JavaScript 包等公共资产放在 blob 存储中：亚马逊 S3 或 谷歌云存储。由于我们要迎合全球受众，并且我们关心拥有一个响应式网站（尤其是网站的主页），因此我们可能希望使用内容交付网络(CDN)来提供该内容。由于手机使用的连接速度较慢，这对于更好的移动体验尤其重要。

## 4 主集群和负载均衡

对于我们的主要后端服务器，我们可以在 2 个重要区域拥有 2 个主集群：北美和印度。

我们可以有一些 DNS 负载均衡来将 API 请求路由到离发出请求的用户最近的集群，并且在一个区域内，我们可以有一些基于路径的负载均衡来分离我们的服务（支付、身份验证、代码执行等）。特别是因为与 API 的其余部分相比，代码执行平台可能需要在不同类型的服务器上运行。每个服务可能有一组服务器，我们可以在该级别进行一些循环负载均衡（这可能直接在基于路径的负载均衡层级中处理）。

## 5 静态 API 内容

AlgoExpert 上有很多静态 API 内容：即问题列表及其所有解决方案。为简单起见，我们可以将所有这些数据存储在 blob 存储中。

## 6 缓存

我们可以为这个静态 API 内容实现 2 层缓存。

我们可以有客户端缓存；这将改善平台上的用户体验（用户只需在每个会话中加载一次问题），这将减少我们后端服务器的负载（这可能会在每个会话中节省 2-3 个网络调用）。

我们还可以在我们的服务器上进行一些内存缓存。如果我们用 10 种语言和每个解决方案 5KB 近似 100 个问题，这应该少于 100 \* 10 = 5000 字节 = 5MB 的总数据要保存在内存中。

由于我们被告知我们希望每隔几天对静态 API 内容进行更改，并且我们希望这些更改尽快反映在全球服务中，因此我们可以每隔 30 分钟左右就使服务器端缓存中的数据无效、驱逐和替换。

## 7 访问控制

每当您设计一个系统时，考虑任何需要实施的潜在访问控制是很重要的。就 AlgoExpert 而言，对于问题内容有直接的访问控制：未购买 AlgoExpert 的用户无法访问个别问题。我们可以很容易地实现这一点，只要用户请求我们的静态 API 内容时进行一些内部 API 调用，以确定用户是否拥有该产品，然后再返回完整的问题内容。

## 8 用户数据存储

对于用户数据，我们必须设计问题完成状态和用户问题解决方案的存储。由于需要大量查询这些数据，因此像 Postgres 或 MySQL 这样的 SQL 数据库似乎是一个不错的选择。

我们可以有 2 张表。第一个表可能是 question_completion_status，它可能具有以下列：

- id：integer，主键（例如自动递增的整数）
- user_id: string，引用用户的 id（可以从 auth 获取）
- question_id: string，引用问题的 id
- completion_status：字符串，枚举表示问题的完成状态

我们可以对 (user_id, question_id) 设置唯一性约束，并在 user_id 上设置索引以保证快速查询。

第二个表可能是 user_solutions：

id：integer，主键（例如自动递增的整数）
user_id: string，引用用户的 id（可以从 auth 获取）
question_id: string，引用问题的 id
language：string，引用解决方案的语言
solution：string，包含用户的解决方案

我们可以在 ( user_id, question_id, language ) 上设置唯一性约束，在 user_id 上设置索引，在 question_id 上设置索引。如果语言数量显着增加，我们可能还希望对语言进行索引以允许快速查询每种语言，这样 UI 就不会同时获取用户的所有解决方案（对于大量数据传输但为慢速连接的情况）。

## 9 存储性能

将问题标记为完整并在编码工作区中键入代码（出于性能原因需要 1-3 秒网络抖动）将发出写入数据库的 API 调用。考虑到我们的用户数量（假设在任何给定时间点平台上大约有 10,000 个用户），我们每秒可能不会获得超过 1000 次写入，而 SQL 数据库肯定可以处理。

我们可以有 2 台主要的数据库服务器，每台都服务于我们的 2 个主要地区：1 台在北美，1 台在印度（可能服务于东南亚）。如果需要，我们可以添加第三个集群，专门服务于欧洲（或世界其他地区，随着我们平台的发展）。

## 10 区域间数据复制

由于我们将有 2 个主数据库服务器，因此我们需要使它们彼此保持最新。幸运的是，AlgoExpert 上的用户不会共享用户生成的内容。这意味着我们不需要将写入 1 个数据库服务器的数据立即写入另一个数据库服务器（这可能会消除我们通过使用区域数据库获得的延迟改进）。

话虽如此，我们确实需要让我们的数据库彼此保持最新，因为用户可能会在世界各地旅行并访问与他们的常驻区域的数据库服务器不同的数据库服务器。

为此，我们可以在数据库服务器之间进行一些异步复制。复制可以每 12 小时执行一次，我们可以根据系统中的行为和跨大陆复制的数据量进行动态调整。

## 11 代码执行

首先，我们应该实施一些速率限制。像代码执行这样的服务非常适合速率限制，我们可以使用 Redis 等 K-V 存储实现一些基于层级的速率限制，以轻松防止 DoS 攻击。我们可以将代码运行次数限制为每秒一次、每 5 秒 3 次和每分钟 5 次。这将通过代码执行 API 防止 DoS 攻击，但在运行代码时仍然可以提供良好的用户体验。

由于我们希望运行代码有 1-3 秒的延迟，因此我们需要保留一组特殊的服务器——我们的“Workers” —— 随时准备运行代码。它们都可以在运行用户代码后进行清理（例如，由于编译而删除额外生成的文件），这样它们就不需要在任何时候被杀死。我们的后端服务器可以通知一个空闲的 Workers，并在该 Workers 完成运行代码（或者如果代码超时）时从该 Workers 那里获得响应，并且我们的服务器可以在同一个请求中将其返回给 UI。

鉴于需要编译某些语言，我们可以估计编译和运行每种语言的代码平均需要 1 秒。人们不经常运行代码，因此我们可以预期每秒总共有 10 个运行代码提交，同时网站上大约有 10,000 个用户，所以我们可能需要 10-100 台机器来满足我们最初的延迟要求，每个代码提交运行 1-3 秒（如果每秒 10 个运行代码是准确的，则为 10 台机器，如果我们遇到更高的负载则按需增加）。

这种设计随着我们的用户数量水平扩展，它可以垂直扩展以使运行代码速度更快（更多 CPU —— 更快的运行速度）。

最后，我们可以在我们的系统中进行一些日志记录和监控，特别是对于运行代码（跟踪每种语言、每个用户、每个问题、平均响应时间等的运行代码事件）。这将帮助我们在用户需求上升或下降时自动扩展集群。这对于了解代码执行引擎是否受到任何恶意攻击行为也很有用。

## 12 架构图

![12 架构图](images/algoexpert-system-diagram.svg)

Last Modified 2022-03-06
