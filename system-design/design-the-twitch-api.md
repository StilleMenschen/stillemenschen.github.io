# 设计：Twitch 直播 API

## 澄清要问的问题

- **问：我将在主播的频道页面上列出不同的功能，以确认我没有遗漏任何重要功能。用户可以观看直播的实际视频（并暂停/取消暂停），他们可以实时看到直播的聊天，可以在聊天中发送消息，他们可以看到主播的频道信息（描述文本、关注者数量、等），他们可以关注和取消关注主播，他们可以订阅和退订主播（他们需要付费订阅），他们可以看到该直播流的当前在线观看人数，他们可以在左侧导航栏上看到其他推荐频道。这涵盖了一切吗？**

  答：可以，但是您可以忽略左侧导航栏上的推荐频道。让我们纯粹关注与页面上的直播相关的功能。

- **问：就订阅而言，据我所知，用户按月订阅，每月收取固定费用。它是否正确？**

  答：可能有不同的订阅级别，但您可以在某些不需要显式定义的 SubscriptionInfo 实体中获得它。

- **问：页面上的很多信息都非常动态，需要经常自动更新，比如关注者数量、同时观看者数量，以及聊天消息和直播本身。我假设我们应该考虑到这一点来设计各种 API 接口；听起来没错吧？**

  答：让我们确保实际的视频和聊天是实时更新的，正如您所期望的那样。然后，让我们尝试每隔一段时间（比如每 30 秒）更新一次当前在线观看人的数量；我们不希望这个数字不断变化，因为这可能会令人不快，特别是有成千上万的观众收看的直播频道。至于关注者数量，我们可以让它在页面刷新时更新。

- **问：澄清一下，对于关注和订阅，我们确实希望将当前用户的关注/订阅状态显示给主播，并且我们希望当用户点击相关的“关注”/“订阅”按钮时立即在 UI 上反映对它的更改，对吧？**

  答：是的，绝对的。如果用户没有关注频道，他们应该会看到该状态反映在页面上，如果他们按下“关注”按钮，他们应该会立即看到更新的状态。订阅也是如此。我们不关心的是实时更新总粉丝数；这就是页面刷新时可以做的事情。

- **问：关于聊天，我知道用户可以发送自定义的 Twitch 表情以及欢呼表情，这是使用 Twitch 的虚拟货币 Bits 购买的特殊动画表情。我们应该在消息传递 API 中处理这些不同类型的表情吗？其他与聊天相关的功能呢，例如被禁止聊天和聊天版主的存在？**

  答：您应该处理所有 Twitch 用户都可以使用的基本 Twitch 表情，但您可以忽略只对订阅者和欢呼表情可用的自定义表情。事实上，对于这个设计，你可以完全忽略 Bits 的概念。您也可以忽略聊天版主，但您应该涵盖禁止功能。具体来说，如果用户被禁止聊天，他们将无法发送消息，但需要在聊天框中以某种方式提醒他们；他们甚至不应该被允许尝试发送消息。

- **问：关于实时视频，我不太熟悉视频（尤其是直播视频）如何在 Web 上大规模运行，但假设 Twitch 后端将能够持续提供一些包含以下内容的 VideoInfo 实体，这是否正确？以及在 UI 上显示视频所需的数据？**

  答：是的，为了这个设计，完全没问题。不必担心显示实时视频的潜在复杂性，例如数据的结构以及如何准确显示它。

## 1 收集要求

与任何 API 设计面试问题一样，我们要做的第一件事就是收集 API 需求；我们需要弄清楚我们正在构建什么 API。

当用户在单个 Twitch 主播的频道页面上观看他们的直播时，我们正在设计与之交互的每个 API 接口。具体来说，我们需要处理：

- 显示主播的频道信息（描述文本、关注者数量等）
- 关注和取消关注主播
- 订阅和取消订阅频道
- 查看实时聊天和发送消息；只有在用户未被禁止的情况下才允许发送消息
- 观看直播并能够暂停/取消暂停视频
- 查看当前直播的在线观看者数量，应该每 30 秒左右自动更新一次

## 2 制定计划

重要的是要将必要的信息组织起来，并就我们将如何处理我们的设计制定一个清晰的计划。我们的 API 中主要的、可能存在争议的部分是什么？我们为什么要做出某些设计决策？

对我们来说幸运的是，我们必须有效支持的各种功能为我们制定了分步计划，因此我们将简单地遵循它。

值得注意的是，默认情况下，我们将定义的所有 API 都将调用者的用户特定身份验证令牌作为授权标头。后端将使用此令牌来识别哪个用户正在调用每个 API 接口。

我们还将 channelId 作为参数传递给所有接口，这将是相关直播的唯一标识。

## 3 频道信息

这是页面上最直接的功能，因为它只包含显示有关流媒体的静态数据。

用户将调用 GetChannelInfo 接口，该接口将返回相关实体 ChannelInfo 以显示在页面上。

ChannelInfo

- name: string
- description: string
- currentStreamTitle: string
- followerCount: int, 关注的人数

这个实体可能有更多的字段，但这些是最重要的。

```
GetChannelInfo(channelId: string)
  => ChannelInfo
```

## 4 关注

关注状态是二元的：用户要么关注主播，要么不关注。因此，我们可以通过使用切换机制的单个接口来支持关注功能，从而后端将关注状态设置为与当前存储在数据库中的状态相反。

```
ToggleFollow(channelId: string)
  => FollowState (FOLLOWING or NOT_FOLLOWING)
```

自然，当用户按下“关注”/“取消关注”按钮时，将调用此接口。

请注意，我们还没有处理如何知道用户的关注状态是什么。换句话说，我们如何知道是向用户显示“关注”还是“取消关注”？有关详细信息，请参阅与频道的关系部分。

## 5 订阅

订阅类似于以下。但是，与以下不同的是，由于用户订阅频道时需要提供更多详细信息（订阅等级和支付信息），因此我们将订阅和取消订阅的行为分为两个接口。

```
CreateSubscription(channelId: string, subscriptionInfo: SubscriptionInfo, paymentInfo: PaymentInfo)
  => Subscription

CancelSubscription(channelId: string)
  => Subscription
```

自然，当用户按下“订阅”/“取消订阅”按钮时，这些接口将被调用。

请注意，我们还没有处理如何知道用户的订阅状态是什么。换句话说，我们如何知道是向用户显示“订阅”还是“取消订阅”？有关详细信息，请参阅与频道的关系部分。

## 6 聊天

为了处理聊天的功能，我们需要两个接口和一个消息实体。

Message

- sender: string, 发送此消息的用户名
- text: string
- timestamp: string, ISO 格式的时间

```
StreamChat(channelId: string)
  => Message

SendMessage(channelId: string, message: string)
  => string | Error if user is banned
```

StreamChat 接口通过长期存在的 websocket 连接流式传输直播内的聊天消息，并将在页面加载时调用一次 。

每当用户发送消息时，自然会调用 SendMessage 接口，我们可以让后端处理消息的时间戳，并在消息实体上提供发送者和时间戳。

我们可以通过用特殊的字符串格式表示 Twitch 表情来处理它们，例如用冒号包装唯一的表情 ID，如下所示：:emote-id:。因此，一条 Twitch 消息将以字符串格式如下所示：

```
"This stream is so fun to watch :kappa:"
```

UI 知道检测这种特殊的字符串格式并适当地显示表情。UI 还知道不显示相关用户发送并通过 StreamChat 接收的消息，因为一旦用户通过 SendMessage 发送这些消息，就会显示这些消息。

如果用户被禁止聊天，SendMessage 会返回错误，但如果用户被禁止聊天，我们实际上不会允许用户发送聊天消息。话虽如此，我们还没有处理如何知道用户是否被禁止。有关详细信息，请参阅与频道的关系部分。

## 7 视频

为了显示实时的视频流，我们将在页面加载时打开另一个长期存在的 websocket 连接，它将流式传输视频。

```
StreamVideo(channelId: string, videoQuality: VideoQuality)
  => VideoInfo
```

当这个接口被调用时，我们可以想象后端增加了某个数据库中相关流的当前观看者计数器，这将在下一节中用于向用户显示当前观看者的数量。当长期连接终止时（在标签关闭或页面离开时），后端将减少数据库中相关的当前观看者计数器。

最后，当用户暂停视频时，UI 仍然会流式传输视频，但不会继续显示。

## 8 当前观看数

通过每 30 秒左右轮询一次接口可以轻松地显示在任何给定时间观看直播的观众数量，该接口从存储每个直播的当前观看者计数器的数据库中读取。

```
GetConcurrentViewers(channelId: string)
  => int
```

## 9 与频道的关系

页面上有一些功能与用户和流媒体之间的关系有关。即用户是否关注主播，是否订阅主播，是否被主播禁止聊天。

处理关注和订阅状态的一种方法是获取用户的个人资料信息，其中可能包含他们所有关注和订阅的流媒体。这将与来自 GetChannelInfo 的流媒体名称一起使用，以在 UI 上显示正确的状态（按钮）。唯一的问题是，理论上用户可能会关注/订阅数千个主播，因此我们可能希望对关注和订阅的主播列表进行分页，这会使事情变得复杂。

为了使事情更简单，并且由于我们还必须处理禁止状态，我们可以依赖 GetRelationshipToChannel 接口，该接口将返回相关实体 RelationshipToChannel，用于在页面上显示正确的状态。

RelationshipToChannel

- isBanned: boolean, 是否被禁言
- isFollowing: boolean, 是否关注
- subscription: Subscription | null, 是否订阅

```
GetRelationshipToChannel(channelId: string)
  => RelationshipToChannel
```

如果用户被禁止发送聊天消息，我们将完全阻止他们发送聊天消息（阻止调用 SendMessage 接口）。

Last Modified 2022-04-10
