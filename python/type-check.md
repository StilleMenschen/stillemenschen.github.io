# 类型检查

## 防御性编程和“快速失败”

防御性编程就像防御性驾驶:有一套提高安全的实践，即使是粗心的程序员（或司机）也不会造成灾难。

许多 bug 只有在运行时才能捕获，即使主流的静态类型语言也是如此（所以需要自动化测试）。对于动态类型语言，“快速失败”可以提升程序的安全性，让程序更易于维护。快速失败的意思是尽早随出运行时错误，例如，在函数主体开头就拒绝无效的参数。

如果一个函数接受一系列项，在内部按照列表处理，那么就不要通过类型检查强制要求传人一个列表。正确的做法是立即利用参数构建一个列表。

```python
def __init__(self， iterable):
    self._balls ＝ list(iterable)
```

这样写出的代码更灵活，因为`list()`构造函数能处理任何在内存中放得下的可迭代对象。如果传入的参数不是可迭代对象，那么初始化对象时`list()`调用就会快速失败，抛出意义十分明确的 `TypeError` 异常。如果想更明确一些，可以把`list()`调用放在`try/except`结构中，自定义错误消息。无论如何，出错的调用将出现在调用跟踪的末尾，直指根源。如果没有在类的构造方法中捕获无效参数，而等到类中的其他方法需要操作`self._balls`时才发现它不是列表，那就为时已晚了，程序崩溃的根源将很难确定。

当然，如果数据太多，或者按照设计，需要就地修改数据（例如 `random.shuffle`）以满足调用方的利益，那么调用`list()`复制数据就不是一个好主意。遇到这种情况，应该使用`isinstance(x，abc.MutableSequence)`做运行时检查。

如果害怕传入的是无穷生成器（不常见），则可以先使用`len()`获取参数的长度。这样可以拒绝迭代器，安全处理元组、数组，以及其他现有或以后可能出现的实现`Sequence`接口的类。调用`len()`的开销通常不大，但是作用明显，遇到无效参数会立即抛出错误。

另外，如果接受任何可迭代对象，那么要尽早调用`iter(x)`，获得一个迭代器。同样，如果 x 不是可迭代对象，则这也会快速失败，抛出一个易于调试的异常。

在这两种情况下，类型提示可以捕获部分问题，但不是所有问题都能提前获知，还记得吗？Any 类型与任何类型都相容。经推导得出的类型就可能是 Any。这时，类型检查工具发挥不了什么作用。而且，类型提示不在运行时强制检查。快速失败是最后一道防线。

利用鸭子类型做防御性编程，无须使用`isinstance()`或`hasattr()`测试就能处理不同的类型。

再举一个例子，模仿 collections.namedtuple 处理 field_names 参数的方式。field_names 参数既可以是各个标识符以空格或逗号分隔的字符串，也可以是标识符序列。利用鸭子类型，可以这样处理

```python
try:
    field_names = field_names.replace(',', ' ').split()
except AttributeError:
    pass
field_names = tuple(field_names)
if not all(s.isidentifier() for s in field_names):
    raise ValueError('field_names must all be valid identifiers')
```

Last Modified 2023-06-03
