# 运行容器

## 什么是容器

容器是一个标准化的软件包，其中包含软件本身以及各个依赖项、配置、数据等运行软件所需的一切。

在 Linux 和大多数其他操作系统中，计算机上运行的一切都是通过进程来完成的。进程表示正在运行的应用程序（例如 Chrome、iTunes 或 Visual Studio Code）的二进制代码和内存状态。所有进程都在同一个全局命名空间中，它们可以相互查看和交互，它们共享同一个资源池，例如 CPU、内存和文件系统等（Linux 的命名空间有点像 Kubernetes 的命名空间，尽管从技术上讲二者不是同一个东西）。

从操作系统的角度来看，容器代表一个（或一组）位于各自命名空间中的隔离进程，容器内部的进程看不到外部的进程，反之亦然。容器不能访问属于其他容器或容器外部进程的资源。容器的边界就像栅栏，可以阻止进程运行异常并耗尽彼此的资源。

对于容器内部的进程而言，它就像在自己的计算机上运行，可以访问所有的资源，而且没有其他正在运行的进程。想验证一下的话，可以试试看在容器运行一些命令：

```
kubectl run alpine --image alpine:3.18 --rm -it --restart=Never /bin/ash
/ # ps ax
PID   USER     TIME  COMMAND
   1 root      0:00   ash
  30 root      0:00   ps ax
/ # hostname
alpine
```

通常， ps ax 命令会列出计算机上运行的所有进程，而且一般会有很多（一般的 Linux 服务器有几百个）。然而，这里仅显示了两个进程: /bin/ash 和 ps ax。因此，容器内部唯一可见的进程就是实际正在容器中运行的进程。hostname 命令通常会返回主机名称，但在这里却显示 alpine，其实这是容器的名称。

容器中其实可以运行一个完整的 Linux 发行版，其中包含多个正在运行的应用程序、网络服务等，这就是为什么容器也会被称为轻量级虚拟机的原因，但这并不是使用容器最佳的方法，因为这样就无法享受资源隔离的优势了。

如果进程不需要彼此了解，那么就不必在同一容器中运行。关于容器，有一个很好的经验法则，即一个容器只做一件事。

容器有一个入口点，即在容器启动时运行的命令。通常运行该命令只需要创建一个进程，尽管某些应用程序通常会启动一些子进程来充当辅助进程或工作进程。如果想在容器中启动多个单独的进程，你需要编写一个包装脚本作为入口，并由脚本来启动你想要的进程。

## Pod 组织容器

以上我们介绍了容器是什么，现在你明白通过 Pod 将容器组织到一起非常有利。Pod 代表一组需要相互通信和共享数据的容器；它们需要一起调度，它们需要一起启动和停止，而且它们还需要在同一台物理计算机上运行。

举一个例子，在本地缓存中保存数据的应用程序，比如 Memcached。你需要运行两个进程：应用程序进程，以及处理存储和检索数据的 memcached 服务器进程。尽管你可以在一个容器中运行这两个进程，但没有必要，因为它们仅需要通过网络 socket 进行通信。最好将它们分到两个单独的容器，每个容器只需要关心构建和运行自己的进程即可。

事实上，你可以使用 Docker Hub 提供的公共 Memcached 容器镜像，它可以直接作为 Pod 的一部分与其他容器一起运行。

因此，你创建的 Pod 拥有两个容器: Memcached，以及你的应用程序。该应用程序可以通过网络连接与 Memcached 通信，并且由于两个容器位于同一个 Pod 中，因此二者之间的连接始终在本地发生，因为这两个容器将始终在同一个节点上运行。

## 容器清单

在一个部署中，`template.spec`用来指定容器

这是一个单容器的部署

```yaml
spec:
  containers:
    - name: nginx
      image: nginx:1.14.2
      ports:
        - containerPort: 80
```

这是一个多容器的部署

```yaml
spec:
  containers:
    - name: container1
      image: example/container1
    - name: container2
      image: example/container2
```

每个容器的规范中必须指定的字段只有 name 和 image，容器必须有名称，以方便其他资源引用，而且你必须告诉 Kubernetes 在容器中运行哪个镜像。

Last Modified 2023-08-16
